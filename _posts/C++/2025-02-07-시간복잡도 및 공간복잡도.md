---
title: 시간복잡도 와 공간복잡도
date: 2025-02-07 01:57:00 +0900
categories: [C++]  
tags:  [ 알고리즘 ]
---

알고리즘을 평가할 때 시간 복잡도와 공간 복잡도를 사용한다.

시간 복잡도와 공간 복잡도는 주로 점근적 표기법 중 Big O 표기법을 이용하여 나타낸다.

그 이유는 최악의 경우에도 해당 알고리즘이 어떤 성능을 낼지 가늠해볼수 있기 때문이다.

작업 할때 최선적으로 O(1)과 O(logN)을 우선으로 해야하고 그렇다 해도 작업하다가

어쩔수 없이 O(n)까지로 할려고 해야한다.

기본적으로 메모리 공간을 많이쓰면 속도가 빨라지고 적게쓰면 연산이 많아진다.

이런 시간과 공간을 조율을 위해 시간복잡도와 공간복잡도를 계산 할 수 있어야한다.

# O(n)
입력받은 수 만큼 반복 하는 경우.
```c++
for(int i = 0; i < length; i++)
{

}
```


O(3n)으로 표기해야 할꺼같지만 간략하게 O(n)으로 표기한다.

빅오표기법은 반복문을 기준으로 성능을 간략하게 표현한다.

```c++
for(int i = 0; i < length; i++)
{

}

for(int i = 0; i < length; i++)
{

}

for(int i = 0; i < length; i++)
{

}
```

# O(1)
입력값과 상관없이 정해진 일정한 속도를 보이면 이건 O(1)로 표현한다.

```c++
for(int i = 0; i < 6; i++)
{
    
}

for(int i = 0; i < 200; i++)
{

}
```

빅오표기법은 통상적으로 O(n)보다 O(1)이 더 빠른 알고리즘이라고 판단한다.

반복횟수가 이중포문으로 100,000,000번이여도 1000 * 100000이면 O(1)이다.

저런 엄청나게 느린 프로그램이여도, 보통 O(n)이 느리다고 판단한다.

그렇기에 밑에 코드의 성능은 O(1)이다.

```c++
for(int i = 0; i < 1000; i++)
{
    for(int j  = 0; j < 100000; j++)
    {
        // O(1)이다.
    }
}
```

# O(n^2)
입력값이 2개가 들어가면 O(n^2)이 된다.

```c++
for(int i = 0; i < n; i++)
{
    for(int j = 0; j < m; j++)
    {
        // 나 O(n^2);
    }
}
```

```c++
for(int i = 0; i < n; i++)
{
    for(int j = 0; j < m; j++)
    {
        
    }
    // 이래도 O(n^2) 이다! 입력값은 2개에서 변하지 않았기 때문
    for(int j = 0; j < m; j++)
    {

    }
}
```


# O(logN)
주로 이진트리에서 이러한 성능이 나오는데 정말 메모리에 직접 접근하는것이 아니면

알고리즘 중 에선 가장 빠른 알고리즘이다.

O(n)에서 n값이 100,000일때 반복 횟수는 100,000번
O(n^2)에서 n값이 100,000일때 반복 횟수는 10,000,000,000번 
O(logN)에서 n값이 100,000일때 반복 횟수는 16번 이다.

# O(nLogN)
logN을 N번 반복하는 알고리즘이다.

O(logN)은 O(1)에 가까운 알고리즘이기 때문에

O(nlogN)은 O(n)과 비슷한 성능을 보인다고 생각하면 된다.

## 시간 체크하는 방법
```c++
#include <iostream>
#include <ctime>
using namespace std;
 
int main() {
    clock_t start, finish;
    double duration;
 
    start = clock();
    
    /*실행 시간을 측정하고 싶은 코드*/
 
    finish = clock();
 
    duration = (double)(finish - start) / CLOCKS_PER_SEC;
    cout << duration << "초" << endl;
 
    return 0;
}
```

# 공간 복잡도 : 메모리 사용량
메모리를 얼만큼 사용하고 있는지를 계산 할 수 있어야 한다. (당연하게도)

![Desktop View](/assets/img/MemoryArea.png){: w="500" h="350" }

코드영역부터 밑으로 할당하고 사용하기 시작하고 순서가 중요하긴 하지만

이 순서는 논리적으로 코드를 바라볼 때 머리에 그려져야 한다. 처음 우리가 짠 코드(프로그램)이

올라가고 정적, 전역변수들이 할당되고 동적할당이 되는데 이건 배열을 해보면 초기화하다 보면 알 수 있다.

int arr[n]은 메모리적으로 불가능하다. n은 정적 변수가 아닌 데다 정적 변수인 int arr에 할당하려고 코드를

짰기 때문이다. 저런 변수들도 프로그램 내 코드들의 일부이기에 가장 먼저 코드영역에 코드가 올라가는 거다.

그림에선 스택 영역이 굉장히 크게 나타나 있는데 실제 메모리 할당 크기는 정말 미세하게 작은 크기다.

VisualStudio에선 기본적으로 1MB로 정해져있는 크기다. (상상이상으로 작다)

# 32bit / 64bit 컴파일
x64는 64비트 컴파일이되고 x86 32비트로 컴파일이 된다.

각각의 데이터 연산의 크기가 다르기떄문에 데이터의 크기도 달라지고 사용가능한 메모리의 양도 다르다.

하지만 최근에는 (2024.05)기준 32비트는 개발되지 않는다고 보면된다.

# 바이트 패딩
패딩이란 구조체나 클래스를 실제로 메모리에 올릴 때, 성능 향상을 위해 추가적인 메모리를 할당하여 넣는 것을 말한다.

## 패딩을 하는 이유(퍼옴)
패딩이란 구조체나 클래스를 실제로 메모리에 올릴 때, 성능 향상을 위해 추가적인 메모리를 할당하여 끼워 넣는 것을 의미한다.

패딩을 하는 이유(인터넷 펌)

메모리에서 CPU 레지스터로 한번에 읽어오는(fetch) 데이터의 크기 때문에 패딩이 일어납니다. 32비트 머신에서는 4바이트 씩이고 64비트 머신에서는 8바이트 씩이겠지요.

이렇게 선언을 하면 메모리 맵상의 어딘가에 영역이 잡히겠죠 그런데 패딩이 없다고 가정하면,


|a|bb|cccc|a|bb|cccc|a|bb|cccc|a|bb|cccc|...


이런식으로 잡히겠죠...

fetch는 4바이트 단위로 이루어지니깐 먄약 첫번째 c를 접근하기 위해서는 2번의 fetch가 이루어져야 합니다.

0번째 바이트부터 3번째 바이트까지 4바이트를 읽어서 그중에 3번째 바이트를 먼저 취하고,
4번째 바이트부터 7번째 바이트까지 4바이트 읽어서 그중에 4~6번째 바이트를 취해서,

둘을 합해 최종 c의 값을 만드는 결과가 생기지요~ 때문에 컴파일러가 패딩을 넣는 겁니다.

한줄요약 : 구조체/클래스 패딩은 구조체 안의 가장 큰 자료형의 크기로 정해진다.

만약 구조체 안에 구조체가 들어가 있다면, 그 구조체 안에서 가장 큰 자료형의 크기로 정해진다.
만약 설정이 8byte 패딩으로 되어 있는데 구조체가

```c++
class C
{
    short a;
    int b;
    int c;
}
```

이와 같이 구성되어 있다면, short-int를 하나로 묶어서 6바이트 + 2바이트 패딩(총 8바이트) int + 패딩 4바이트 (총 8바이트)

식으로 묶는다.  (단, short는 2bytes, int는 4bytes일 때의 풀이이다) 만약 설정이 4bytes 패딩이라면,

short a;   //4bytes
int b;     //4bytes
int c;     //4bytes

총 12 바이트가 된다.
