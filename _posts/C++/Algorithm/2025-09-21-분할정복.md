---
title: 분할정복 (Divide and Comquer)
date: 2025-09-21 02:58:00 +0900
categories: [C++]  
tags:  [ Algorithm ]
---

## 분할정복 ?
--------------------------------
문제 해결 전략 중 하나로 문제를 유사한 작은 문제들로 쪼개어 해결한 후

이 해결한 작은 문제들의 결과를 활용해서 원래 문제를 해결하는 방식이다!

이 설명 생각해 보면 어디서 본 적이 있다. 그것은 바로 가장 최근에 한 "병합 정렬"이다.

병합 정렬은 분할 정복을 이용하는 정렬로 분할 정복을 설명하는데 있어 아주 제격이라 할 수 있다.


## 분할정복의 핵심개념
--------------------------------
1. 문제를 비슷한 작은 문제들로 쪼갠다. 쪼개는 방식은 보통 재귀를 많이 사용한다.

2. 작게 쪼갠 문제들을 해결하고 그 결과들을 이용해 원래 문제를 해결한다.

이 두 개가 전부이고 이해하기 쉽?진 않을 수 있다. 그래도 유명한 알고리즘이며 다른 무서운 알고리즘에 비해

이해하기 쉬운 편에 속하니 잘 알아두도록 하자.

분할 정복의 예는 병합 정렬 구현으로 남기도록 한다.

## 병합 정렬 구현

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void Merge(vector<int>& vec, int mid, int left, int right)
{
    // 각 나누어진 배열의 크기를 지정
	int leftArrCount = mid - left + 1;
	int rightArrCount = right - mid;

	vector<int> leftArr(leftArrCount), rightArr(rightArrCount);

    // 나누어진 각 배열에 값을 할당
	for (int i = 0; i < leftArrCount; i++)
		leftArr[i] = vec[left + i];

	for (int i = 0; i < rightArrCount; i++)
		rightArr[i] = vec[mid + i + 1];

    // 각 배열을 정렬
	int leftIndex = 0, rightIndex = 0, i = left;
	while (leftIndex < leftArrCount && rightIndex < rightArrCount)
	{
		if (leftArr[leftIndex] <= rightArr[rightIndex])
		{
			vec[i] = leftArr[leftIndex];
			leftIndex++;
		}
		else
		{
			vec[i] = rightArr[rightIndex];
			rightIndex++;
		}

		i++;
	}

	while (leftIndex < leftArrCount)
	{
		vec[i] = leftArr[leftIndex];
		leftIndex++;
		i++;
	}

	while (rightIndex < rightArrCount)
	{
		vec[i] = rightArr[rightIndex];
		rightIndex++;
		i++;
	}
}

void MergeSort(vector<int>& vec, int left, int right)
{
	if (left >= right) // 못 나눌때 까지 쪼갠다.
		return;

	int mid = left + (right - left) / 2;
	MergeSort(vec, left, mid);
	MergeSort(vec, mid + 1, right);

	// 작은 문제들의 결과를 도출하고, 이 결과들로 상위 문제의 결과로 만든다.
	Merge(vec, mid, left, right);
}

int main()
{
	vector<int> vec(n);
	MergeSort(vec, 0, vec.size() - 1);
	return 0;
}
```
