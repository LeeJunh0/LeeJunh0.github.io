---
title: 플로이드 워셜? (Floyd-WarShall)
date: 2025-05-22 18:29:00 +0900
categories: [C++]  
tags:  [ Algorithm ]
---

## 플로이드 워셜이란 ?
--------------------------------

플로이드 워셜은 "모든 지점" 에서 "다른 모든 지점" 까지의 최단 경로를 "모두" 구하는 알고리즘이다!!

딱 ~ 봐도 엄청나게 시간복잡도가 높을꺼같은 알고리즘입니다. 그죠?

무려 O(n^3) 입니다. 엄청 느리죠?

플로이드 워셜의 핵심은 거쳐가는 노드를 기준으로 최소 경로를 구하는것 입니다.

그래프에는 예를 들어 1 -> 3으로 가는 비용이 10 이라고 가정할 때, 1에서 출발 해서 3으로 끝나는 경로를 모두 탐색한다 생각하면 됩니다.

1 -> 2 비용이 2, 2 -> 3 비용이 7일 경우 경로의 합이 9로 1 -> 3으로 가는 비용과 1 -> 2 -> 3으로 가는 비용을 비교해서 더 작은 값으로

최신화 시켜줍니다. 이런 방식으로 모든 경로에서의 최소 경로를 구하는 것이 플로이드 워셜입니다.

위의 예를 식으로 만들면 이런 모양입니다.

```c++
// 출발지점 i, 거쳐가는지점 k, 도착지점 j
graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
```

## 구현 예

```c++
int n;
vector<vector<int>> graph(n, vector<int>(n, INT_MAX));

for(int i = 0; i < n; i++)
    graph[i][i] = 0; // 자기 자신에 대한 경로!

for (int k = 0; k < n; k++)
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            // 둘 중 한개는 갈수 없는 경로이기 때문에 패스
            if (graph[i][k] == INT_MAX || graph[k][j] == INT_MAX)
                continue;

            // 0은 자기자신에 대한 정점이기 때문에 경로 값이 없으니 패스
            if (graph[i][k] == 0 || graph[k][j] == 0)
                continue;

            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
        }
    }
}
```
