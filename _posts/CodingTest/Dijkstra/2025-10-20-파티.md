---
title: C++ 백준 1238번 / 파티
date: 2025-10-20 22:00:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, Dijkstra ]
---

백준 1238번 문제인 파티 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/파티.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>
#include <queue>

#define INF 9999999
using namespace std;

struct Node
{
	int node;
	int time;

	Node(int mNode, int mTime) : node(mNode), time(mTime)
	{}
};

vector<int> Dijkstra(vector<vector<Node>>& graph, int start)
{
	vector<int> dist(graph.size() + 1, INF);
	priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int,int>>> que;

	que.push({ 0, start });
	dist[start] = 0;
	while (que.empty() == false)
	{
		int cur = que.top().second;
		int time = que.top().first;
		que.pop();

		if (dist[cur] < time)
			continue;

		for (int i = 0; i < graph[cur].size(); i++)
		{
			int next = graph[cur][i].node;
			int nextTime = graph[cur][i].time + time;

			if (dist[next] > nextTime)
			{
				que.push({ nextTime, next });
				dist[next] = nextTime;
			}
		}
	}

	return dist;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n, m, x;
	cin >> n >> m >> x;

	vector<vector<Node>> graph(n + 1);
	vector<vector<Node>> BackGraph(n + 1);
	for (int i = 0; i < m; i++)
	{
		int start, end, time;
		cin >> start >> end >> time;
		graph[start].push_back(Node(end, time));
		BackGraph[end].push_back(Node(start,time));
	}

	vector<int> dist(n + 1, INF);
	vector<int> start(n + 1);
	vector<int> xStart(n + 1);

	start = Dijkstra(graph, x);
	xStart = Dijkstra(BackGraph, x);

	int maxTime = 0;
	for (int i = 1; i < start.size() - 1; i++)
		maxTime = max(maxTime, start[i] + xStart[i]);

	cout << maxTime << '\n';
	return 0;
}
```
---------------------------------------

# 후기

원래 풀이는 학생 n만큼 다익스트라를 하고 도착지에 다익스트라를 해서 총 n + 1번을 돌렸지만

해당 코드는 x에서 한번, 원래 그래프에서 역뱡향으로 한번 총 2번으로 해결한 문제였다.

원래는 우선순위 큐로 하지않았고 그로 시간초과가 났지만 우선순위 큐로 해결 후 최적화했다.
