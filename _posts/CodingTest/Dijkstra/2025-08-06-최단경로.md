---
title: C++ 백준 1753번 / 최단경로
date: 2025-08-06 12:37:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, Dijkstra ]
---

백준 1753번 문제인 최단경로 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/최단경로.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int v, e;
    cin >> v >> e;
    int start;
    cin >> start;
    vector<vector<pair<int, int>>>map(v + 1);
    vector<int> distance(v + 1, INT32_MAX);
    distance[start] = 0;
    for (int i = 0; i < e; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        map[a].push_back({ c,b });
    }
    
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({ 0,start });
    
    while (pq.empty() == false)
    {
        pair<int,int> cur = pq.top();
        pq.pop();
        
        if (distance[cur.second] < cur.first) continue;
        
        for (int i = 0; i < map[cur.second].size(); i++) 
        {
            pair<int, int> next = map[cur.second][i];
            if (distance[next.second] > distance[cur.second] + next.first)
            {
                distance[next.second] = distance[cur.second] + next.first;
                pq.push({ distance[next.second], next.second });
            }
        }
    }
    
    for (int i = 1; i <= v; i++)
    {
        if (distance[i] == INT32_MAX)
            cout << "INF" << '\n';
        else
            cout << distance[i] << '\n';
    }
    
    return 0;
}
```
---------------------------------------

# 후기

전에 문제는 정확한 다익스트라 알고리즘으로 풀었던것이 아니였다.

알아보니 우선순위 큐를 써서 항상 가중치가 작은 순으로 탐색하는것이 원칙인 알고리즘이였기 때문이다.

그렇게 이번엔 우선순위 큐를 사용해 풀었는데 푸는 도중 pair는 정렬할 때 first의 값을 기준으로 정렬한다는걸 알았다.

pair의 first에 노드를 넣어 풀었을 때 테케는 잘 풀렸지만 결국 시간초과가 나와 알아보니 정렬이 가중치 기준으로 되고 있지 않다는 점 때문이였다.

그래서 노드와 가중치의 위치를 바꾸고 푸니 잘 해결되었다.
