---
title: C++ 백준 1916번 / 최소비용구하기
date: 2025-10-20 18:30:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, Dijkstra ]
---

백준 1916번 문제인 최소비용구하기 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/최소비용구하기.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>
#define INF 99999999

using namespace std;

int Dijkstra(vector<vector<int>>& graph, int start, int end)
{
	vector<int> dist(graph.size());
	vector<int> visited(graph.size(), false);

	for (int i = 1; i < graph.size(); i++)
		dist[i] = graph[start][i];

	visited[start] = true;
	for (int i = 1; i < graph.size() - 2; i++)
	{
		int min = INF;
		int idx = 0;

		for (int j = 1; j < graph.size(); j++)
		{
			if (min > dist[j] && visited[j] == false)
			{
				min = dist[j];
				idx = j;
			}
		}

		visited[idx] = true;
		for (int j = 1; j < graph.size(); j++)
		{
			if (visited[j] == true)
				continue;

			dist[j] = std::min(dist[j], dist[idx] + graph[idx][j]);
		}
	}

	return dist[end];
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n, m;
	cin >> n;
	cin >> m;
	vector<vector<int>> graph(n + 1, vector<int>(n + 1, INF));
	for (int i = 1; i <= n; i++)
		graph[i][i] = 0;

	for (int i = 0; i < m; i++)
	{
		int start, node, cost;
		cin >> start >> node >> cost;
		if (graph[start][node] != 0)
			graph[start][node] = min(cost, graph[start][node]);
	}

	int start, end;
	cin >> start >> end;
	cout << Dijkstra(graph, start, end) << '\n';

	return 0;
}
```
---------------------------------------

# 후기

특정 지점에서 모든 지점의 최소 거리 혹은 비용을 구하는 알고리즘인 다익스트라 문제다.

해당 풀이는 인접행렬 방식으로 간선은 작고 정점이 많은 비정상적 그래프에서는 너무나 비효율적이니 인지하고 보도록하자.

다익스트라는 기본적으로 현재 지점에서 가장 비용 혹은 거리가 작은 노드부터 탐색을 하는 알고리즘이다, 즉 탐욕(그리드)다.

가장 작은것부터 차근차근 비용을 비교하며 최소비용을 구하는 거다.
