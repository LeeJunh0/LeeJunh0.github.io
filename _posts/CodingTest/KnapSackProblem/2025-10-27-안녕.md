---
title: C++ 백준 1535번 / 안녕
date: 2025-10-27 06:20:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, Greed, KnapSack ]
---

백준 1535번 문제인 안녕 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/안녕.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>

using namespace std;

struct Happy
{
	int lost;
	int gain;
	Happy(int mLost, int mGain) : lost(mLost), gain(mGain)
	{}
};

int dp[21][101] = {};

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n;
	cin >> n;
	vector<Happy> happy(n + 1, {0, 0});
	for (int i = 1; i <= n; i++)
		cin >> happy[i].lost;

	for (int i = 1; i <= n; i++)
		cin >> happy[i].gain;

	for (int i = 1; i <= n; i++)
	{
		for (int hp = 1; hp < 100; hp++)
		{
			if (happy[i].lost > hp)
			{
				dp[i][hp] = dp[i - 1][hp];
				continue;
			}

			if (happy[i].gain + dp[i - 1][hp - happy[i].lost] < dp[i - 1][hp])
				dp[i][hp] = dp[i - 1][hp];
			else
				dp[i][hp] = happy[i].gain + dp[i - 1][hp - happy[i].lost];

		}
	}

	cout << dp[n][99] << '\n';
	return 0;
}
```
---------------------------------------

# 후기

배낭문제 알고리즘을 공부하고 풀어본 문제였다.

처음에 최선의 선택을 하도록 슬픔/행복의 비율이 가장 큰 순으로 정렬해서 순차적으로 더 하도록 만들어보기도 하고

DFS로 모든 경우의 수를 탐색하기도 해봤지만 둘다 되지않았고 결국 배낭문제라는것은 DP를 사용하여 풀어야하는 문제인듯 하다.

배낭문제의 핵심은 "현재 가방무게에 들어가는 최대가치"를 구하는 것이다. 테이블에 해당 물건을 넣을지 말지로 로직을 만들어보면 된다.

전의 최대가치보다 그걸 빼고 현재 물건을 넣는게 크면 최신화해주고 아닐경우 이전의 값을 넣어 테이블을 초기화 해주도록 테이블을 채워넣는다.

이후 최대무게, 최대 물건 수에 저장되어있는 값을 출력하면 된다. 물론 이건 분할이 가능하지 않은 물건일 경우의 알고리즘이다.
