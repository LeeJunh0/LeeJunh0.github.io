---
title: C++ 백준 1337번 / 올바른배열
date: 2025-09-26 10:53:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, TwoPointer ]
---

백준 1337번 문제인 올바른배열 (이)다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/올바른배열.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n;
	cin >> n;
	vector<int> vec(n);
	for (int i = 0; i < n; i++)
		cin >> vec[i];

	sort(vec.begin(), vec.end());
	
	int count;
	int maxCount = 0;
	for (int i = 0; i < n; i++)
	{
		count = 0;
		for (int j = i; j < i + 5; j++)
		{
			if (j >= n)
				break;

			if (vec[j] <= vec[i] + 4)
			{
				count++;
				maxCount = max(maxCount, count);
			}
			else
				break;
		}
	}

	cout << 5 - maxCount << '\n';
	return 0;
}
```
---------------------------------------

# 후기

투 포인터 알고리즘을 알게된 문제였다.

단순 2중 for문으로는 시간제한에 걸리기 때문에 다른 방법을 알아야했다.

5개의 연속배열을 알아내야 했기때문에 sort로 정렬한 후 왼쪽부터 5개씩 보기로 했고

연결이 될 수 있는 수인지 체크하고 아닐경우 0부터 다시 샐수있도록 하여 풀었다.


