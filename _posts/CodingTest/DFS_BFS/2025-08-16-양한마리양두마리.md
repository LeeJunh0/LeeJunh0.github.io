---
title: C++ 백준 11123번 / 양한마리양두마리
date: 2025-08-16 11:15:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, BFS ]
---

백준 11123번 문제인 양한마리양두마리 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/양한마리양두마리.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>

using namespace std;

void DFS(vector<vector<char>>& map, vector<vector<int>>& visited, int y, int x)
{
    if (y >= map.size() || x >= map[0].size() || y < 0 || x < 0)
        return;
    
    if (visited[y][x] == true)
        return;
    
    if (map[y][x] == '.')
        return;
    
    visited[y][x] = true;
    
    DFS(map, visited, y, x + 1);
    DFS(map, visited, y, x - 1);
    DFS(map, visited, y + 1, x);
    DFS(map, visited, y - 1, x);
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int t;
    cin >> t;
    
    for (int i = 0; i < t; i++)
    {
        int h, w;
        cin >> h >> w;
        vector<vector<char>> map(h, vector<char>(w));
        vector<vector<int>> visited(h, vector<int>(w, false));
        for (int j = 0; j < h; j++)
        {
            for (int k = 0; k < w; k++)
                cin >> map[j][k];
        }
    
        int grid = 0;
        for (int j = 0; j < h; j++)
        {
            for (int k = 0; k < w; k++)
            {
                if (map[j][k] == '#' && visited[j][k] == false)
                {
                    grid++;
                    DFS(map, visited, j, k);
                }
            }
        }
    
        cout << grid << '\n';
    }

    return 0;
}
```
---------------------------------------

# 후기

치즈 이후 다시 DFS와 BFS의 숙련도를 올리기 위해 DFS/BFS의 문제들을 싹 풀기로 했다.

맵의 양 무리가 몇 그룹이나 있는지 확인하는 문제였다. 그룹을 확인하는 문제들은 대부분

맵을 순회하며 양이 발견될 때마다 탐색을 해 현재 양과 같은 그룹인 양들을 전부 true 체크해준 후

그룹 수를 카운트 해주고 다시 맵을 순회하면서 양이 발견될 때는 처음 양 그룹과는 다른 양의 등장이기에

다시 탐색하는 식으로 그룹을 찾아 나가는 방식이다. 그룹이라 얘기했지만 범위체크에 해당하는 부분이다.
