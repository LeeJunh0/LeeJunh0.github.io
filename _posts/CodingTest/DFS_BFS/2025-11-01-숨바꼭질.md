---
title: C++ 백준 1697번 / 숨바꼭질
date: 2025-10-29 13:20:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, DFS, BFS, Graph, ]
---

백준 1697번 문제인 숨바꼭질 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/숨바꼭질.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <queue>

using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n, k;
	cin >> n >> k;

	queue<pair<int, int>> que;
	que.push({ n, 0 });

	int visited[100001] = { false, };
	visited[n] = true;

	while (que.empty() == false)
	{
		pair<int, int> cur = que.front();
		que.pop();

		if (cur.first == k)
		{
			cout << cur.second << '\n';
			break;
		}

		if (cur.first + 1 >= 0 && cur.first + 1 <= 100000)
		{
			if (visited[cur.first + 1] == false)
			{
				visited[cur.first + 1] = true;
				que.push({ cur.first + 1, cur.second + 1 });
			}
		}

		if (cur.first - 1 >= 0 && cur.first - 1 <= 100000)
		{
			if (visited[cur.first - 1] == false)
			{
				visited[cur.first - 1] = true;
				que.push({ cur.first - 1, cur.second + 1 });
			}
		}

		if (cur.first * 2 >= 0 && cur.first * 2 <= 100000)
		{
			if (visited[cur.first * 2] == false)
			{
				visited[cur.first * 2] = true;
				que.push({ cur.first * 2, cur.second + 1 });
			}
		}
	}

	return 0;
}
```
---------------------------------------

# 후기

BFS로 현재 값에서 모든 경우를 전부 탐색하며 중복과 범위체크만 해주면서 탐색하면 된다.
