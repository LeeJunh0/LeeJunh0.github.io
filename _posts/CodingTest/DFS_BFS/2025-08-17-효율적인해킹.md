---
title: C++ 백준 1325번 / 효율적인해킹
date: 2025-08-17 18:21:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, DFS ]
---

백준 1325번 문제인 효율적인해킹 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/효율적인해킹.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>

using namespace std;

vector<vector<int>> graph;
vector<int> visited;

void DFS(int y, int& cur)
{
    visited[y] = true;
    
    if (graph[y].empty() == true)
        return;
    
    for (int i = 0; i < graph[y].size(); i++)
    {
        if (visited[graph[y][i]] == true)
            continue;
        
        cur++;
        DFS(graph[y][i], cur);
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int n, m;
    cin >> n >> m;
    
    graph.resize(n + 1);
    for(int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        graph[b].emplace_back(a);
    }
    
    int maxCount = 0;
    vector<int> results(n + 1, 0);
    for (int i = 1; i <= n; i++)
    {
        visited.assign(n + 1, false);
        DFS(i, results[i]);
        maxCount = max(maxCount, results[i]);
    }
    
    for (int i = 1; i <= n; i++)
    {
        if (maxCount == results[i])
            cout << i << ' ';
    }
    
    return 0;
}
```
---------------------------------------

# 후기

DFS/BFS 문제를 풀며 시간초과와 메모리초과를 본건 처음이였다. 그걸 해결하고자 방법을 찾은것도 처음이였고 말이다.

방문체크를해서 중복을 없애고 2차원배열이긴하지만 인접리스트로 만들어 바로 해당 인덱스로 접근 가능하도록 구현했다.

그러니 정말 겨우겨우 시간초과를 해결했다...
