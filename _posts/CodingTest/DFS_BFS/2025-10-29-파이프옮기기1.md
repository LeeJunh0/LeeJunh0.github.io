---
title: C++ 백준 17070번 / 파이프옮기기1
date: 2025-10-29 13:20:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, DFS, BFS, Graph, ]
---

백준 17070번 문제인 파이프옮기기1 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/파이프옮기기1.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>

using namespace std;

int map[17][17] = {};
int visited[17][17] = {};
int result = 0;

enum class temp
{
	Horizontal,
	Vertical,
	Diagonal
};

void DFS(int y, int x, temp type, int n)
{
	if (y >= n || x >= n)
		return;

	if (type == temp::Diagonal)
	{
		if (map[y - 1][x] == 1 || map[y][x - 1] == 1 || map[y][x] == 1)
			return;
	}
	else
	{
		if (map[y][x] == 1)
			return;
	}

	if (y == n - 1 && x == n - 1)
	{
		result++;
		return;
	}

	if (type == temp::Vertical)
	{
		DFS(y, x + 1, temp::Vertical, n);
		DFS(y + 1, x + 1, temp::Diagonal, n);
	}
	else if (type == temp::Horizontal)
	{
		DFS(y + 1, x, temp::Horizontal, n);
		DFS(y + 1, x + 1, temp::Diagonal, n);
	}
	else
	{
		DFS(y, x + 1, temp::Vertical, n);
		DFS(y + 1, x, temp::Horizontal, n);
		DFS(y + 1, x + 1, temp::Diagonal, n);
	}

	return;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n;
	cin >> n;

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
			cin >> map[i][j];
	}

	visited[0][0] = true;
	DFS(0, 1, temp::Vertical, n);
	cout << result << '\n';
	return 0;
}
```
---------------------------------------

# 후기

DFS를 사용해 첫 지점에서 갈 수 있는 경로로 목표지점을 가면 카운팅해주었다.

다 풀고 나니 DP였다는 점에서 "음... DP일수도 있겠네 싶었다."
