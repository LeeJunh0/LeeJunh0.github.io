---
title: C++ 백준 2638번 / 치즈
date: 2025-08-15 11:57:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, BFS ]
---

백준 2638번 문제인 치즈 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/치즈.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int direct[4][2] = { 0,1,0,-1,1,0,-1,0 };
int n, m;
queue<pair<int, int>> cheeseQue;

vector<vector<int>> OutSideAirSearch(vector<vector<int>>& map)
{
    vector<vector<int>> visited(map.size(), vector<int>(map[0].size(), false));
    queue<pair<int, int>> que;
    que.push({ 0,0 });
     
    while (que.empty() == false)
    {
        pair<int, int> cur = que.front();
        que.pop();
         
        for (int i = 0; i < 4; i++)
        {
            int newY = direct[i][0] + cur.first;
            int newX = direct[i][1] + cur.second;
             
            if (newY >= n || newX >= m || newY < 0 || newX < 0)
                continue;
             
            if (visited[newY][newX] == true)
                continue;
             
            if (map[newY][newX] == 0)
            {
                que.push({ newY,newX });
                visited[newY][newX] = true;
            }
        }
    }
     
    return visited;
}

void CheeseSearch(vector<vector<int>>& map)
{
    int result = 0;
    queue<pair<int, int>> meltCheese;
    vector<vector<int>> visited = OutSideAirSearch(map);
    visited[cheeseQue.front().first][cheeseQue.front().second] = true;
    
    while (cheeseQue.empty() == false)
    {
        int curSize = cheeseQue.size();
        for (int i = 0; i < curSize; i++)
        {
            pair<int, int> cur = cheeseQue.front();
            cheeseQue.pop();
            
            int air = 0;
            for (int i = 0; i < 4; i++)
            {
                int newY = direct[i][0] + cur.first;
                int newX = direct[i][1] + cur.second;
                
                if (newY >= n || newX >= m || newY < 0 || newX < 0)
                    continue;
                
                if (map[newY][newX] == 0 && visited[newY][newX] == true)
                    air++;
            }
            
            if (air >= 2)
                meltCheese.push(cur);
            else
                cheeseQue.push(cur);
        }
        
        if (meltCheese.size() > 0)
        {
            while (meltCheese.empty() == false)
            {
                pair<int, int> melt = meltCheese.front();
                map[melt.first][melt.second] = 0;
                visited[melt.first][melt.second] = true;
                meltCheese.pop();
            }
            
            result++;
            visited = OutSideAirSearch(map);
        }
    }
    
    cout << result << '\n';
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    std::cout.tie(NULL);
    
    int count = 0;
    cin >> n >> m;
    vector<vector<int>> map(n, vector<int>(m));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> map[i][j];
            if (map[i][j] == 1)
                cheeseQue.push({ i,j });
        }
    }
    
    CheeseSearch(map);
    return 0;
}
```
---------------------------------------

# 후기

너무 갑자기 올라간 난이도때문인지 내가 BFS와 DFS의 이해가 떨어지는건지 양쪽인건지 모르겠다.

아무튼 이번 문제로 꽤나 이해도가 올라간건 사실이다. 서론이 길었지만 치즈 이 문제. 원래 좀 낮은 난이도의 문제들은

BFS나 DFS를 한번하고 그 한번으로 답을 뽑아 낼수있었지만 이 문제는 그렇지않았다. 탐색한번 싹 하고 다시 한번 해주고를 반복하며

치즈가 다 녹았는지 계속 계속 확인해줘야했다. 그것만 안다면 바로 풀 수 있는 문제다. 한번에 얽혀 있으면 평생 못푼다.
