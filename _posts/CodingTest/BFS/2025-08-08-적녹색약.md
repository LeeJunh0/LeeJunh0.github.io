---
title: C++ 백준 10026번 / 적녹색약
date: 2025-08-08 10:27:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, BFS ]
---

백준 10026번 문제인 적녹색약 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/적녹색약.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <string>
#include <queue>

using namespace std;

int direct[4][2] = { 0,1,0,-1,1,0,-1,0 };

void BFS(vector<vector<char>>& map, vector<vector<int>>& visited,int y, int x, char color)
{
    visited[y][x] = true;
    queue<pair<int, int>> que;
    que.push({ y,x });
    
    while (que.empty() == false)
    {
        pair<int, int> curPos = que.front();
        que.pop();
        
        for (int i = 0; i < 4; i++)
        {
            int newY = direct[i][1] + curPos.first;
            int newX = direct[i][0] + curPos.second;
            
            if (newY < 0 || newX < 0 || newY >= map.size() || newX >= map.size())
                continue;
            
            if (visited[newY][newX] == true || map[newY][newX] != color)
                continue;
            
            que.push({ newY,newX });
            visited[newY][newX] = true;
        }
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int n;
    cin >> n;
    vector<vector<char>> map(n, vector<char>(n));
    vector<vector<char>> diffMap(n, vector<char>(n));
    vector<vector<int>> normalVisited(n, vector<int>(n, false));
    vector<vector<int>> diffVisited(n, vector<int>(n, false));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            char a;
            cin >> a;
            map[i][j] = a;
            if (a == 'G')
                diffMap[i][j] = 'R';
            else
                diffMap[i][j] = a;
        }
    }
    
    int normal = 0;
    int diff = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (normalVisited[i][j] == false)
            {
                normal++;
                BFS(map, normalVisited,i, j, map[i][j]);
            }
            
            if (diffVisited[i][j] == false)
            {
                diff++;
                BFS(diffMap, diffVisited, i, j, diffMap[i][j]);
            }
        }
    }
    
    cout << normal << ' ' << diff << '\n';
    return 0;
}
```
---------------------------------------

# 후기

전에 DFS로 풀었던 문제를 BFS로 다시 풀어본 문제다.

색약이 있는사람과 없는사람의 관점에서 보이는 공간의 수를 알아내 출력하는 문제로

색약인 사람과 아닌사람의 map과 visited를 따로 저장해 하나의 BFS로 해결했으며

각 현재 탐색지점이 방문되어있지 않을때마다 들어가서 각 색깔을 방문체크하며 수를 더해나가면 된다.

BFS 각 지점을 최대 1번씩만 방문한다해도 2중 for문이기 때문에 시간복잡도는 O(n^2)이다...
