---
title: 백준 1991번 / 트리순회
date: 2025-10-09 15:10:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, tree ]
---

백준 1991번 문제인 트리순회이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/트리순회.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

#define Fast ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)

using namespace std;

void Preorder(unordered_map<char, vector<char>>& tree, char root)
{
	if (root == '.')
		return;

	cout << root;
	Preorder(tree, tree[root][0]);
	Preorder(tree, tree[root][1]);
}
void Inorder(unordered_map<char, vector<char>>& tree, char root)
{
	if (root == '.')
		return;

	Inorder(tree, tree[root][0]);
	cout << root;
	Inorder(tree, tree[root][1]);
}
void Postorder(unordered_map<char, vector<char>>& tree, char root)
{
	if (root == '.')
		return;

	Postorder(tree, tree[root][0]);
	Postorder(tree, tree[root][1]);
	cout << root;
}

int main()
{
	int n;
	cin >> n;
	unordered_map<char, vector<char>> tree;
	for (int i = 0; i < n; i++)
	{
		char cur, left, right;
		cin >> cur >> left >> right;
		tree[cur].push_back(left);
		tree[cur].push_back(right);
	}

	Preorder(tree, 'A');
	cout << '\n';
	Inorder(tree, 'A');
	cout << '\n';
	Postorder(tree, 'A');

	return 0;
}
```
---------------------------------------

# 후기

입력값이 부모, 왼쪽, 오른쪽으로 들어오는 트리를 전위, 중위, 후위 순회하며 출력하는 문제로 

Node를 만드는 대신 vector에 왼쪽 오른쪽 노드를 저장해 재귀적으로 순회하도록 구현했다.


