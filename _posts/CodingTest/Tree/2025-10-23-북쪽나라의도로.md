---
title: 백준 1595번 / 북쪽나라의도로
date: 2025-10-23 18:41:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, tree ]
---

백준 1595번 문제인 북쪽나라의도로이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/북쪽나라의도로.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>

using namespace std;

struct Node
{
	int node;
	int cost;

	Node(int mNode, int mCost) : node(mNode), cost(mCost)
	{}
};

int maxNode, maxCost;

void DFS(vector<vector<Node>>& map, vector<bool>& visited, int cur, int curCost)
{
	if (maxCost < curCost)
	{
		maxNode = cur;
		maxCost = curCost;
	}

	for (int i = 0; i < map[cur].size(); i++)
	{
		if (visited[map[cur][i].node] == true)
			continue;

		visited[map[cur][i].node] = true;
		DFS(map, visited, map[cur][i].node, curCost + map[cur][i].cost);
	}
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	vector<vector<Node>> map(10000);
	int a, b, c;
	while (cin >> a >> b >> c)
	{
		if (cin.eof())
			break;

		map[a].push_back({ b, c });
		map[b].push_back({ a,c });
	}

	vector<bool> visited(map.size(), false);
	visited[1] = true;
	DFS(map, visited, 1, 0);

	fill(visited.begin(), visited.end(), false);
	visited[maxNode] = 1;
	maxCost = 0;
	DFS(map, visited, maxNode, 0);

	cout << maxCost << '\n';
	return 0;
}
```
---------------------------------------

# 후기

트리의 지름을 사용하는 문제로 10000번 까지 노드가 있을수 있기 때문에 인접리스트를 사용했고

아니였어도 인접행렬을 사용하지는 않았을것같다.
