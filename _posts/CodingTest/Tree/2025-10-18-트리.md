---
title: 백준 1068번 / 트리
date: 2025-10-18 02:04:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, tree ]
---

백준 1068번 문제인 트리이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/트리.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>

using namespace std;

int leaf = 0;
int root = 0;

// 생각안했던 점
// 루트노드가 0이 아닐수도있다는 것
// 루트노드만 남았을 때 상황
// 루트노드를 잘랐을 때 상황
// 잘라야하는 노드를 정말 배열에서 삭제했을 경우 for문의 상태
// 이진트리가 아닐수도 있다는 것
void DFS(vector<vector<int>>& map, int cur, int cut) 
{
	int count = 0;
	for (int i = 0; i < map[cur].size(); i++)
	{
		if (map[cur][i] == cut)
			continue;

		count++;
		DFS(map, map[cur][i], cut);
	}

	if (count <= 0)
		leaf++;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n;
	cin >> n;
	vector<vector<int>> map(n + 1);
	for (int i = 0; i < n; i++)
	{
		int parent;
		cin >> parent;
		if (parent == -1)
		{
			root = i;
			continue;
		}

		map[parent].push_back(i);
	}

	int cut;
	cin >> cut;
	if (root == cut)
	{
		cout << 0 << '\n';
		return 0;
	}

	DFS(map, root, cut);
	cout << leaf << '\n';
	return 0;
}
```
---------------------------------------

# 후기

루트노드가 불확실하고 이진트리도 아닐수도 있는 트리의 리프노드 개수를 세는 문제였다...ㅠ

주의점만 잘 준수하면서 DFS나 BFS로 순회하며 리프노드를 카운팅해주면 된다.
