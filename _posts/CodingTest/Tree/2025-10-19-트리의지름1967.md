---
title: 백준 1967번 / 트리의지름
date: 2025-10-19 06:40:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, tree ]
---

백준 1967번 문제인 트리의지름이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/트리의지름1967.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>

using namespace std;

struct NodeInfo
{
	int node;
	int weight;

	NodeInfo(int mNode, int mWeight) : node(mNode), weight(mWeight)
	{}
};


int node;
int maxLength = 0;
void DFS(vector<vector<NodeInfo>>& tree, vector<int>& visited, int cur, int length)
{
	if (visited[cur] == true)
		return;

	visited[cur] = true;
	if (maxLength < length)
	{
		maxLength = length;
		node = cur;
	}

	for (int i = 0; i < tree[cur].size(); i++)
	{
		if (visited[tree[cur][i].node] == true)
			continue;

		DFS(tree, visited, tree[cur][i].node, length + tree[cur][i].weight);
	}
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n;
	cin >> n;
	vector<vector<NodeInfo>> tree(n + 1);
	for (int i = 0; i < n - 1; i++)
	{
		int parent, child, weight;
		cin >> parent >> child >> weight;
		tree[parent].push_back(NodeInfo(child, weight));
		tree[child].push_back(NodeInfo(parent, weight));
	}

	vector<int> visited(n + 1, false);
	DFS(tree, visited, 1, 0);

	fill(visited.begin(), visited.end(), false);
	maxLength = 0;
	DFS(tree, visited, node, 0);

	cout << maxLength << '\n';
	return 0;
}
```
---------------------------------------

# 후기

트리의 지름 1167번을 풀고 제대로 이해했는지 알기 위해 같은 알고리즘의 다른 문제를 풀었다.

사실 그 문제랑 다를게 거의없다.. 이 문제도 메모리제한이 128MB로 크기않고 V도 10000으로 1167번의 10만보다는 작지만

인접행렬로 접근했을 때 계산해보면 10000 x 10000 = 1억이고 int를 저장한다 가정하면 4byte니까 4억byte 즉 380메가 쪼금 넘는다

그럼 바로 메모리 터지고 아웃이다. 그러니 이 문제도 인접리스트로 풀어야한다.
