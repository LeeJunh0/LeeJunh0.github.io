---
title: C++ 백준 1091번 / 카드섞기
date: 2025-10-12 12:54:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, Implement ]
---

백준 1091번 문제인 카드섞기 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/카드섞기.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>
#include <set>

#define Fast ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);

using namespace std;

int main()
{
	int n;
	cin >> n;
	vector<int> s(n);
	vector<int> p(n);
	vector<int> card;

	for (int i = 0; i < n; i++)
	{
		card.push_back(i);
		cin >> p[i];
	}

	for (int i = 0; i < n; i++)
		cin >> s[i];

	int shuffleCount = 0;
	while (true)
	{
		bool isComplete = true;
		for (int i = 0; i < p.size(); i++)
		{
			if (p[card[i]] != i % 3)
			{
				isComplete = false;
				break;
			}
		}

		if (isComplete == true)
			break;

		vector<int> temp(n);
		for (int i = 0; i < s.size(); i++)
			temp[s[i]] = card[i];

		card = temp;

		if (shuffleCount > 10000000)
		{
			shuffleCount = -1;
			break;
		}

		shuffleCount++;
		continue;
	}

	cout << shuffleCount << '\n';
	return 0;
}
```
---------------------------------------

# 후기

지문이 좀 이해하기 어렵던 문제다. 이 문제의 핵심은 정해진 셔플법으로 셔플했을때

카드들이 P의 순서에 맞는지 확인하는게 핵심이였다. 즉 p의 card[i]가 i % 3 인가가 중요하다.

이후는 temp에 셔플법대로 섞은 카드를 넣고 그걸 card에 넣어주면서 반복하며 카운팅한다.

또 문제였던점은 무한대로 섞는게 아닌 "섞다 안나오면 -1을 출력해!" 이 부분인데 이 부분은 2가지를 써봤다.

시간제한에 걸리지 않는 선에서 최대한의 카운팅을 해보는것과 카드순서를 저장하고 셔플한 순서랑 같은지 확인하는 방법이였다.

시간제한은 최악 정말 아슬아슬하게까지 시간복잡도를 요구하지만, 카드저장은 공간을 꽤 잡아먹을것이다. 그래도... 아마 저장이 괜찮지 않을까 싶다.




