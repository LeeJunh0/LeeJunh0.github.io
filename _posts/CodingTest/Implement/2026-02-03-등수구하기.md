---
title: C++ 백준 1205번 / 등수구하기
date: 2026-02-03 18:00:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, Implement ]
---

백준 1205번 문제인 등수구하기 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/등수구하기.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <bits/stdc++.h>
#include <unordered_map>

using namespace std;

int main()
{
	int n, score, p;
	cin >> n;
	cin >> score;
	cin >> p;
	vector<int> scoreList;
	unordered_map <int, int> map(n);
	for (int i = 0; i < n; i++)
	{
		int cur;
		cin >> cur;
		if (find(scoreList.begin(), scoreList.end(), cur) == scoreList.end())
			scoreList.push_back(cur);

		map[cur]++;
	}

	int result = 1;
	int cnt = 0;
	for (int i = 0; i < scoreList.size(); i++)
	{
		if (scoreList[i] > score)
			result += map[scoreList[i]];
		else if (scoreList[i] == score)
			cnt += map[scoreList[i]];
	}

	if (result == 0)
		result = 1;

	if (result + cnt > p)
		result = -1;

	cout << result << '\n';

	return 0;
}
```
---------------------------------------

# 후기

재활로 풀어본 문제 2였다. 너무 오래걸린다 실버4인데.. 한 시간쯤 걸린듯 하다.

머리에 막 이런저런 방법이 떠오르는데 왜 계속 손이 안움직일까.. 코드가 안써진다..

일단 생각한 방법으로는 각 점수들의 카운팅을 한다.

내 점수보다 현재 점수가 크면 그 숫자만큼 순위에 바로 반영한다.

하지만 같으면 순위는 같겠지만 점수리스트에서 밀리기때문에 따로 저장해둔다.

마지막에 순위 + 리스트에서 밀린순 을 더했을 때 p보다 크면 점수리스트에 오르지 못하기때문에

-1을 출력해주고 0일 경우 점수리스트가 비어있기 때문에 1위로 출력해주었다.

떠오른 방법에 이진탐색도 있었다. 이미 정렬된 리스트를 받는거기 때문에.
