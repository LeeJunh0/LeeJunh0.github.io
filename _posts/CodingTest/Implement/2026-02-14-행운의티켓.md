---
title: C++ 백준 1639번 / 행운의티켓
date: 2026-02-14 02:24:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, Implement ]
---

백준 1639번 문제인 행운의티켓 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/행운의티켓.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <bits/stdc++.h>
#include <unordered_map>

using namespace std;

int StringToSum(string s)
{
	int result = 0;
	for (int i = 0; i < s.size(); i++)
		result += s[i] - '0';

	return result;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cout.tie(NULL);
	cin.tie(NULL);

	string str;
	cin >> str;

	int length = 1;
	int result = INT_MIN;
	for (int i = 0; i < str.size(); i++)
	{
		length = 1;
		for (int j = i + 1; j < str.size(); j++)
		{
			string leftStr = str.substr(i, length);
			string rightStr = str.substr(j, length);

			if (leftStr.size() != rightStr.size())
				break;

			int left = StringToSum(leftStr);
			int right = StringToSum(rightStr);
			
			if (left == right)
				result = max(result, length * 2);

			length++;
		}
	}

	if (result == INT_MIN)
		cout << 0 << "\n";
	else
		cout << result << '\n';

	return 0;
}
```
---------------------------------------

# 후기

구현을 골드이상까진 실력을 올려야 한다!! 그래야 실력이 맘에 들 거 같다.

앞과 뒤를 같은 길이로 체크해가며 그걸 한자리 한자리 전부 합친 값이 같을 때 그 길이가

가장 긴 값을 출력하는 문제였다.

이 문제의 핵심은 "문장을 순회하면서 같은 길이로 체크해 나가는 것 이다."




