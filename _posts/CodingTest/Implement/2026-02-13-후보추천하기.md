---
title: C++ 백준 1713번 / 후보추천하기
date: 2026-02-13 01:47:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, Implement ]
---

백준 1713번 문제인 후보추천하기 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/후보추천하기.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <bits/stdc++.h>
#include <unordered_map>

using namespace std;

struct Student
{
	int num;
	int curJoayo;
	int day;
};

vector<Student> candidates;

int StudentFind(int num)
{
	int result = -1;
	for (int i = 0; i < candidates.size(); i++)
	{
		if (num == candidates[i].num)
		{
			result = i;
			break;
		}
	}

	return result;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cout.tie(NULL);
	cin.tie(NULL);

	int n;
	cin >> n;
	int joayo;
	cin >> joayo;

	for (int i = 0; i < joayo; i++)
	{
		int student;
		cin >> student;

		int idx = StudentFind(student);
		if (idx < 0)
		{
			if (candidates.size() >= n)
			{
				vector<Student> temp;
				int minJoayo = INT_MAX;
				for (int j = 0; j < candidates.size(); j++)
					minJoayo = min(minJoayo, candidates[j].curJoayo);

				for (int j = 0; j < candidates.size(); j++)
				{
					if (minJoayo == candidates[j].curJoayo)
						temp.push_back(candidates[j]);
				}

				std::sort(temp.begin(), temp.end(), [](Student& a, Student& b) {
					if (a.curJoayo == b.curJoayo)
					{
						return a.day > b.day;
					}

					return a.curJoayo > b.curJoayo;
				});

				int minIdx = StudentFind(temp.back().num);
				candidates[minIdx] = { student,1, i };
			}		
			else
				candidates.push_back({ student, 1, i });
		}
		else
			candidates[StudentFind(student)].curJoayo++;		
	}

	std::sort(candidates.begin(), candidates.end(), [](Student& a, Student& b) {
		return a.num < b.num;
	});

	for (int i = 0; i < candidates.size(); i++)
		cout << candidates[i].num << " ";

	return 0;
}
```
---------------------------------------

# 후기

규칙을 그대로 구현하는 문제였다.

1. 새로운 후보가 들어오면 무조건 넣어야한다.

2. 다 차있으면 적은 사람이랑 교체한다.

3. 적은사람이 2명이상이면 가장 오래된사람이랑 교체한다.

4. 오름차순으로 정렬해서 출력.

이렇게 하면 되는 문제였다.


