---
title: C++ 백준 1756번 / 피자굽기
date: 2026-02-21 03:21:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, Implement ]
---

백준 1756번 문제인 피자굽기 이다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/피자굽기.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <bits/stdc++.h>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<int> ovenDepth;

int BinarySearch(int start, int end, int target)
{
	while (start < end)
	{
		int mid = (start + end) / 2;

		if (ovenDepth[mid] >= target)
			start = mid + 1;
		else
			end = mid;
	}

	return start - 1;
}

int main() 
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int d, n;
	cin >> d >> n;

	ovenDepth.resize(d);

	cin >> ovenDepth[0];
	int result = d;

	for (int i = 1; i < d; i++)
	{
		cin >> ovenDepth[i];
		ovenDepth[i] = min(ovenDepth[i], ovenDepth[i - 1]);
	}

	for (int i = 0; i < n; i++)
	{
		int size;
		cin >> size;
		result = BinarySearch(0, result, size);

		if (result < 0)
		{
			cout << 0 << '\n';
			return 0;
		}
	}

	cout << result + 1 << '\n';
	return 0;
}
```
---------------------------------------

# 후기

처음엔 DFS방식을이용해 계속 들어갈 수 있는 자리를 탐색하며 방문체크를 해 풀었는데..

이 방식은 N^2으로 시간초과가 났다. 그래서 방식을 달리 생각해야 했는데 이 문제의 핵심은 

피자는 가장 먼저 들어간 반죽 밑으로는 들어가지 못한다! 즉. 입력값이 들어올 때 마다 최대 깊이가 줄어든다.

그렇다는건 앞 깊이와 현재 깊이를 비교해 작은 값으로 덮어도 된다는 의미다! 깊이가 6 5 3이 있을경우 현재가 5일때

6은 5로 덮어도 무방하다는것이다. 이 생각을 바탕으로 진행하면 당연하게도 깊이 배열이 내림차순 정렬이 되는데

정렬이 된걸보고 이진탐색이 바로 떠올라 구현해 풀었다.




