---
title: C++ 백준 1074번 / Z
date: 2025-09-21 23:26:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, DivideandConsquer ]
---

백준 1074번 문제인 Z (이)다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/Z.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <cmath>

using namespace std;

int Zoptimize(int length, int r, int c, int y, int x, int count)
{
    if (y == r && x == c)
        return count;
    
    if (y > r || y + length < r || x > c || x + length < c)
        return count + pow(count, 2);
    
    length /= 2;
    
    if (y + length > r && x + length > c)
        return Zoptimize(length, r, c, y, x, count);
    else if (y + length > r && x + length <= c)
        return Zoptimize(length, r, c, y, x + length, count + pow(length, 2));
    else if (y + length <= r && x + length > c)
        return Zoptimize(length, r, c, y + length, x, count + pow(length, 2) * 2);
    else
        return Zoptimize(length, r, c, y + length, x + length, count + pow(length, 2) * 3);
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int n;
    cin >> n;
    int r, c;
    cin >> r >> c;
    cout << Zoptimize(pow(2, n), r, c, 0, 0, 0) << '\n';
    return 0;
}
```
---------------------------------------

# 후기

분할 정복을 사용해 푸는 문제였고, 자력으로는 풀지 못했다.

위 코드는 다른 분들에 풀이를 보고 코드를 해석하고 이해한 후 나의 코드로 만들고 최적화를 한 코드라는 것.

코드를 풀어 해설하면 이 문제는 "r, c라는 좌표값에 언제 방문하는지" 체크하는 문제로 배열이 필요없는 것이다.

목표위치에 방문하면 Zoptimize는 즉각 카운팅을 종료하는 조건을 걸어 재귀에 제한을 걸고 시작했다.

문제를 보면 Z모양으로 탐색하는걸 볼수있는데, 이 부분을 보고 알 수있는건 length 즉 탐색의 최소길이가 2이다.

또, 탐색의 시작 위치는 항상 왼쪽모서리가 시작이며 현재 위치에서 현재 탐색길이 length안에 목표위치가 없거나?

현재위치보다 목표위치가 더 작은 곳에 있을 때 즉. 현재 탐색범위 밖에 목표가 있을 때 모든 칸을 일일이 카운팅 하지않고

탐색해야했던 범위를 한번에 카운팅하고 넘어가도록 했다. 이후 4분면을 조건으로 각 분면에 맞는 카운팅을 진행하여 풀어주었다.



