---
title: C++ 백준 2630번 / 색종이만들기
date: 2025-09-21 03:30:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, DivideandConsquer ]
---

백준 2630번 문제인 색종이만들기 (이)다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/색종이만들기.png){: w="700" h="400" }

---------------------------------------

# 풀이 1
```c++
#include <iostream>
#include <vector>

using namespace std;

struct Count
{
    int WhiteCount;
    int BlueCount;

    Count(int w, int b) : WhiteCount(w), BlueCount(b)
    {}

    Count& operator+=(Count value)
    {
        this->WhiteCount += value.WhiteCount;
        this->BlueCount += value.BlueCount;
        return *this;
    }
};

bool PaperSearching(vector<vector<int>>& paper, int curN, int y, int x)
{
    for (int i = y; i < y + curN; i++)
    {
        for (int j = x; j < x + curN; j++)
        {
            if (paper[y][x] != paper[i][j])
                return false;
        }
    }

    return true;
}

Count DividAndConsquer(vector<vector<int>>& paper, int curN, int y, int x)
{
    if (PaperSearching(paper, curN, y, x) == true)
    {
        if (paper[y][x] == 0)
            return Count(1, 0);
        else
            return Count(0, 1);
    }

    Count PaperCount(0, 0);
    curN /= 2;

    PaperCount += DividAndConsquer(paper, curN, y, x);
    PaperCount += DividAndConsquer(paper, curN, y, x + curN);
    PaperCount += DividAndConsquer(paper, curN, y + curN, x);
    PaperCount += DividAndConsquer(paper, curN, y + curN, x + curN);

    return PaperCount;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int n;
    cin >> n;
    vector<vector<int>> paper(n, vector<int>(n));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
            cin >> paper[i][j];
    }

    Count result = DividAndConsquer(paper, n, 0, 0);
    cout << result.WhiteCount << '\n';
    cout << result.BlueCount << '\n';
    return 0;
}
```

# 풀이 2

```c++
#include <iostream>
#include <vector>

using namespace std;

int blue = 0;
int white = 0;

struct Point
{
    int X;
    int Y;
    
    Point(int y, int x) : Y(y), X(x)
    {}
    
    Point& operator+= (int value)
    {
        this->Y += value;
        this->X += value;
        return *this;
    }
};

void Cutting(vector<vector<int>>& paper, int n, Point& pivot)
{
    if (n <= 1)
    {
        if (paper[pivot.Y][pivot.X] == 0)
            white++;
        else
            blue++;
        
        return;
    }
    
    bool isCheck = true;
    for (int i = pivot.Y; i < n + pivot.Y; i++)
    {
        for (int j = pivot.X; j < n + pivot.X; j++)
        {
            if (paper[i][j] == paper[pivot.Y][pivot.X])
                continue;
            
            isCheck = false;
            break;
        }
        
        if (isCheck == false)
            break;
    }
    
    if (isCheck == false)
    {
        int mid = n / 2;
        
        Point pos1(pivot.Y, pivot.X + mid);
        Point pos2(pivot.Y + mid, pivot.X);
        Point pos3(pivot.Y + mid, pivot.X + mid);
        
        Cutting(paper, n / 2, pivot);
        Cutting(paper, n / 2, pos1);
        Cutting(paper, n / 2, pos2);
        Cutting(paper, n / 2, pos3);
    }
    else
    {
        if (paper[pivot.Y][pivot.X] == 0)
            white++;
        else
            blue++;
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int n;
    cin >> n;
    vector<vector<int>> colorPaper(n, vector<int>(n));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
            cin >> colorPaper[i][j];
    }
    
    Point pos(0, 0);
    Cutting(colorPaper, n, pos);
    
    cout << white << '\n' << blue << '\n';
    return 0;
}
```
---------------------------------------

# 후기

분할 정복을 직접 찾아보고 공부해서 푼 첫 문제다.

분할 정복은 문제를 쪼개 작은 문제들의 결과로 본래 문제의 해답을 얻는 문제 해결 유형 중 한개로 

분할 정복 문제의 특징은 전체에서 특정 범위에 값이 몇 개인지 같은 전체를 개별로 쪼개는걸 권장하는 문제들이

주를 이루는것 같다. 이 문제도 마찬가지로 색종이에서 같은 색끼리 몇 장씩 있는지 찾는 문제였다.

현재 좌표의 색종이 색깔과 다른 색깔이 있으면 4등분을 한다. 이것을 해당 범위의 색깔이 전부 같을때 까지 실행한다.

이후 제각각 1, 4, 16 ... 의 크기로 종이를 잘리는데 종이에 색이 전부 같으면 어떤 색인지 카운팅 해주고 상위 크기로 돌아가는 식이다.

