---
title: C++ 백준 2630번 / 색종이만들기
date: 2025-03-10 23:49:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, DivideandConsquer ]
---

백준 2630번 문제인 색종이만들기 (이)다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/색종이만들기.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>

using namespace std;

int blue = 0;
int white = 0;

struct Point
{
	int X;
	int Y;

	Point(int y, int x) : Y(y), X(x)
	{}

	Point& operator+= (int value)
	{
		this->Y += value;
		this->X += value;
		return *this;
	}
};

void Cutting(vector<vector<int>>& paper, int n, Point& pivot)
{
	if (n <= 1)
	{
		if (paper[pivot.Y][pivot.X] == 0)
			white++;
		else
			blue++;

		return;
	}

	bool isCheck = true;
	for (int i = pivot.Y; i < n + pivot.Y; i++)
	{
		for (int j = pivot.X; j < n + pivot.X; j++)
		{
			if (paper[i][j] == paper[pivot.Y][pivot.X])
				continue;

			isCheck = false;
			break;
		}

		if (isCheck == false)
			break;
	}

	if (isCheck == false)
	{
		int mid = n / 2;

		Point pos1(pivot.Y, pivot.X + mid);
		Point pos2(pivot.Y + mid, pivot.X);
		Point pos3(pivot.Y + mid, pivot.X + mid);

		Cutting(paper, n / 2, pivot);
		Cutting(paper, n / 2, pos1);
		Cutting(paper, n / 2, pos2);
		Cutting(paper, n / 2, pos3);
	}
	else
	{
		if (paper[pivot.Y][pivot.X] == 0)
			white++;
		else
			blue++;
	}
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n;
	cin >> n;
	vector<vector<int>> colorPaper(n, vector<int>(n));
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
			cin >> colorPaper[i][j];
	}

	Point pos(0, 0);
	Cutting(colorPaper, n, pos);

	cout << white << '\n' << blue << '\n';
	return 0;
}
```
---------------------------------------

# 후기

입력값이 부모, 왼쪽, 오른쪽으로 들어오는 트리를 

전위, 중위, 후위 순회하며 출력하는 문제로 map에 부모인덱스로

왼쪽 오른쪽 노드를 저장해 DFS에서 이름으로 순회하도록 구현했다.


