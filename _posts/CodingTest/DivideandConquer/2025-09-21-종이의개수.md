---
title: C++ 백준 1780번 / 종이의개수
date: 2025-09-21 04:45:00 +0900
categories: [ CodingTest ]  
tags:  [ C, C++, DivideandConsquer ]
---

백준 1780번 문제인 종이의개수 (이)다.

# 문제   
---------------------------------------

![Desktop View](/assets/img/종이의개수.png){: w="700" h="400" }

---------------------------------------

# 풀이

```c++
#include <iostream>
#include <vector>

using namespace std;

int a, b, c;

void PaperCounting(vector<vector<int>>& paper, int y, int x)
{
	if (paper[y][x] == -1)
		a++;
	else if (paper[y][x] == 0)
		b++;
	else
		c++;

	return;
}

void PaperCutting(vector<vector<int>>& paper, int length, int y, int x)
{
	if (length <= 1)
	{
		PaperCounting(paper, y, x);
		return;
	}

	bool isCheck = true;
	for (int i = y; i < length + y; i++)
	{
		for (int j = x; j < length + x; j++)
		{
			if (paper[y][x] == paper[i][j])
				continue;

			isCheck = false;
			break;
		}
		
		if (isCheck == false)
			break;
	}

	if (isCheck == true)
		PaperCounting(paper, y, x);
	else
	{
		int mid = length / 3;
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				int newY = y + mid * i;
				int newX = x + mid * j;
				PaperCutting(paper, mid, newY, newX);
			}
		}
	}

	return;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n;
	cin >> n;
	vector<vector<int>> paper(n, vector<int>(n));
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
			cin >> paper[i][j];
	}

	PaperCutting(paper, n, 0, 0);
	cout << a << '\n' << b << '\n' << c << '\n';
	return 0;
}
```
---------------------------------------

# 후기

분할 정복을 정복하기 위해 분할정복 문제만 우다다 풀 예정이다.

이번 문제는 색종이자르기와 유사한 문제로 접근 방법도 유사하다.

모든 종이를 탐색하며 다른 종이가 있으면 그 종이를 9등분으로 자른다.

자른 종이를 다시 탐색하고 모두 같으면 어떤 종이인지 카운팅하고 상위 종위로 돌아가도록 했다.


